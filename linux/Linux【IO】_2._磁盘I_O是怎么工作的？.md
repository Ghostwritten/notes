



--------------------------
## 1. 回顾

文件系统是对存储设备上的文件，进行组织管理的一种机制。而 Linux 在各种文件系统实现上，又抽象了一层虚拟文件系统 VFS，它定义了一组，所有文件系统都支持的，数据结构和标准接口。这样，对应用程序来说，只需要跟 VFS 提供的统一接口交互，而不需要关注文件系统的具体实现；对具体的文件系统来说，只需要按照 VFS 的标准，就可以无缝支持各种应用程序。

VFS 内部又通过目录项、索引节点、逻辑块以及超级块等数据结构，来管理文件。

 - **目录项**，记录了文件的名字，以及文件与其他目录项之间的目录关系。
 - **索引节点**，记录了文件的元数据。
 - **逻辑块**，是由连续磁盘扇区构成的最小读写单元，用来存储文件数据。
 - **超级块**，用来记录文件系统整体的状态，如索引节点和逻辑块的使用情况等。


其中，目录项是一个内存缓存；而超级块、索引节点和逻辑块，都是存储在磁盘中的持久化数据。那么，进一步想，磁盘又是怎么工作的呢？又有哪些指标可以用来衡量它的性能呢？接下来，我就带你一起看看， Linux 磁盘 I/O 的工作原理。

##  2. 磁盘
磁盘是可以持久化存储的设备，根据存储介质的不同，常见磁盘可以分为两类：**机械磁盘和固态磁盘。**

第一类，**机械磁盘**，也称为**硬盘驱动器**（Hard Disk Driver），通常缩写为 **HDD**。机械磁盘主要由盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位到数据所在的磁道，然后才能访问数据。

显然，如果 I/O 请求刚好连续，那就不需要磁道寻址，自然可以获得最佳性能。这其实就是我们熟悉的，连续 I/O 的工作原理。与之相对应的，当然就是随机 I/O，它需要不停地移动磁头，来定位数据位置，所以读写速度就会比较慢。

第二类，**固态磁盘**（Solid State Disk），通常缩写为 **SSD**，由固态电子元器件组成。固态磁盘不需要磁道寻址，所以，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。

其实，无论机械磁盘，还是固态磁盘，相同磁盘的随机 I/O 都要比连续 I/O 慢很多，原因也很明显。

 - 对机械磁盘来说，我们刚刚提到过的，由于随机 I/O 需要更多的磁头寻道和盘片旋转，它的性能自然要比连续 I/O 慢。
 - 而对固态磁盘来说，虽然它的随机性能比机械硬盘好很多，但同样存在“先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以相对应的，随机 I/O 的性能比起连续 I/O 来，也还是差了很多。
 - 此外，连续 I/O 还可以通过预读的方式，来减少 I/O 请求的次数，这也是其性能优异的一个原因。很多性能优化的方案，也都会从这个角度出发，来优化 I/O 性能。

此外，机械磁盘和固态磁盘还分别有一个最小的读写单位。

 - 机械磁盘的最小读写单位是扇区，一般大小为 512 字节。
 - 而固态磁盘的最小读写单位是页，通常大小是 4KB、8KB 等。

在上一节中，我也提到过，**如果每次都读写 512 字节这么小的单位的话，效率很低。所以，文件系统会把连续的扇区或页，组成逻辑块，然后以逻辑块作为最小单元来管理数据。常见的逻辑块的大小是 4KB，也就是说，连续 8 个扇区，或者单独的一个页，都可以组成一个逻辑块。**

除了可以按照**存储介质**来分类，另一个常见的分类方法，是按照**接口**来分类，比如可以把硬盘分为 IDE（Integrated Drive Electronics）、**SCSI**（Small Computer System Interface） 、**SAS**（Serial Attached SCSI） 、**SATA**（Serial ATA） 、**FC**（Fibre Channel） 等。

不同的接口，往往分配不同的设备名称。比如， **IDE 设备会分配一个 hd 前缀的设备名，SCSI 和 SATA 设备会分配一个 sd 前缀的设备名**。如果是多块同类型的磁盘，就会按照 a、b、c 等的字母顺序来编号。


除了磁盘本身的分类外，当你把磁盘接入服务器后，按照**不同的使用方式**，又可以把它们划分为多种不同的架构。

最简单的，就是直接作为独立磁盘设备来使用。这些磁盘，往往还会根据需要，划分为不同的逻辑分区，每个分区再用数字编号。比如我们前面多次用到的 `/dev/sda` ，还可以分成两个分区 `/dev/sda1` 和 `/dev/sda2`。

另一个比较常用的架构，是把多块磁盘组合成一个**逻辑磁盘**，构成**冗余独立磁盘阵列**，也就是 `RAID`（Redundant Array of Independent Disks），从而可以提高数据访问的性能，并且增强数据存储的可靠性。

根据容量、性能和可靠性需求的不同，RAID 一般可以划分为多个级别，如 `RAID0、RAID1、RAID5、RAID10` 等。

RAID0 有最优的读写性能，但不提供数据冗余的功能。而其他级别的 RAID，在提供数据冗余的基础上，对读写性能也有一定程度的优化。

最后一种**架构**，是把这些磁盘组合成一个**网络存储集群**，再通过 **NFS、SMB、iSCSI** 等网络存储协议，暴露给服务器使用。

其实在 Linux 中，磁盘实际上是作为一个**块设备**来管理的，也就是以块为单位读写数据，并且支持**随机读写**。每个块设备都会被赋予两个设备号，分别是**主、次**设备号。**主设备号用在驱动程序中，用来区分设备类型；而次设备号则是用来给多个同类设备编号。**


##  3. 通用块层
跟我们上一节讲到的虚拟文件系统 VFS 类似，为了减小不同块设备的差异带来的影响，Linux 通过一个统一的通用块层，来管理各种不同的块设备。**通用块层，其实是处在文件系统和磁盘驱动中间的一个块设备抽象层。**它主要有两个功能 。

 - 第一个功能跟虚拟文件系统的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序。
 - 第二个功能，通用块层还会给文件系统和应用程序发来的 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率。

其中，对 **I/O 请求排序**的过程，也就是我们熟悉的 **I/O 调度**。事实上，Linux 内核支持四种 I/O 调度算法，分别是 `NONE`、`NOOP`、`CFQ` 以及 `DeadLine`。

 - 第一种 `NONE` ，更确切来说，并不能算 I/O 调度算法。因为它完全不使用任何 I/O 调度器，对文件系统和应用程序的 I/O其实不做任何处理，常用在虚拟机中（此时磁盘 I/O 调度完全由物理机负责）。
 - 第二种 `NOOP` ，是最简单的一种 I/O 调度算法。它实际上是一个**先入先出**的队列，只做一些最基本的请求合并，常用于 SSD 磁盘。
 - 第三种 `CFQ`（Completely Fair Scheduler），也被称为**完全公平调度器**，是现在很多发行版的默认 I/O 调度器，它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。

类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度，所以它适用于运行大量进程的系统，像是桌面环境、多媒体应用等。


最后一种 **DeadLine 调度算法**，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。

## 4. I/O 栈

清楚了磁盘和通用块层的工作原理，再结合上一期我们讲过的文件系统原理，我们就可以整体来看 Linux 存储系统的 I/O 原理了。

我们可以把 Linux 存储系统的 I/O 栈，由上到下分为三个层次，分别是文件系统层、通用块层和设备层。这三个 I/O 层的关系如下图所示，这其实也是 Linux 存储系统的 I/O 栈全景图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210712153623222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpeGloYWhhbGVsZWhlaGU=,size_16,color_FFFFFF,t_70)
根据这张 I/O 栈的全景图，我们可以更清楚地理解，存储系统 I/O 的工作原理。

 - **文件系统层**，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。
 - **通用块层**，包括块设备 I/O 队列和 I/O 调度器。它会对文件系统的 I/O请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。
 - **设备层**，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。

存储系统的 I/O ，通常是整个系统中最慢的一环。所以， Linux 通过多种缓存机制来优化 I/O 效率。

 - 比方说，为了优化文件访问的性能，会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，以减少对下层块设备的直接调用。
 - 同样，为了优化块设备的访问效率，会使用缓冲区，来缓存块设备的数据。




##  5. 磁盘性能指标

说到磁盘性能的衡量标准，必须要提到五个常见指标，也就是我们经常用到的，**使用率、饱和度、IOPS、吞吐量以及响应时间等**。这五个指标，是衡量磁盘性能的基本指标。

 - **使用率**，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈。
 - **饱和度**，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O请求。
 - **IOPS**（Input/Output Per Second），是指每秒的 I/O 请求数。
 - **吞吐量**，是指每秒的 I/O 请求大小。
 - **响应时间**，是指 I/O 请求从发出到收到响应的间隔时间。


这里要注意的是，使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受新的 I/O 请求。

这些指标，很可能是你经常挂在嘴边的，一讨论磁盘性能必定提起的对象。不过我还是要强调一点，不要孤立地去比较某一指标，而要结合`读写比例`、`I/O 类型（随机还是连续）`以及 `I/O 的大小`，综合来分析。

举个例子，在数据库、大量小文件等这类随机读写比较多的场景中，IOPS 更能反映系统的整体性能；而在多媒体等顺序读写较多的场景中，`吞吐量`才更能反映系统的整体性能。

一般来说，我们在为应用程序的服务器选型时，要先对磁盘的 I/O 性能进行基准测试，以便可以准确评估，磁盘性能是否可以满足应用程序的需求。

这一方面，我推荐用性能测试工具 `fio` ，来测试`磁盘的 IOPS`、`吞吐量`以及`响应时间`等核心指标。但还是那句话，因地制宜，灵活选取。在基准测试时，一定要注意根据应用程序 I/O 的特点，来具体评估指标。

当然，这就需要你测试出，不同 I/O 大小（一般是 512B 至 1MB 中间的若干值）分别在**随机读、顺序读、随机写、顺序写**等各种场景下的性能情况。

用性能工具得到的这些指标，可以作为后续分析应用程序性能的依据。一旦发生性能问题，你就可以把它们作为磁盘性能的极限值，进而评估磁盘 I/O 的使用情况。了解磁盘的性能指标，只是我们 I/O 性能测试的第一步。接下来，又该用什么方法来观测它们呢？这里，我给你介绍几个常用的 I/O 性能观测方法。

## 6. 磁盘 I/O 观测
第一个要观测的，是每块磁盘的使用情况。[iostat](https://ghostwritten.blog.csdn.net/article/details/117707478) 是最常用的磁盘 I/O 性能观测工具，它提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，当然，这些指标实际上来自  `/proc/diskstats`。iostat 的输出界面如下。


```bash
# -d -x表示显示所有磁盘I/O的指标
$ iostat -d -x 1 
Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util 
loop0            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
loop1            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
sda              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
sdb              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00 
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210713140236462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpeGloYWhhbGVsZWhlaGU=,size_16,color_FFFFFF,t_70)
这些指标中，你要注意：

 - %util  ，就是我们前面提到的磁盘 I/O 使用率；
 - r/s+  w/s  ，就是 IOPS；
 - rkB/s+wkB/s ，就是吞吐量；
 - r_await+w_await ，就是响应时间。

在观测指标时，也别忘了结合请求的大小（ `rareq-sz 和 wareq-sz`）一起分析。你可能注意到，从 iostat 并不能直接得到磁盘饱和度。事实上，饱和度通常也没有其他简单的观测方法，不过，你可以把观测到的，平均请求队列长度或者读写请求完成的等待时间，跟基准测试的结果（比如通过 fio）进行对比，综合评估磁盘的饱和情况。


## 7. 进程 I/O 观测
除了每块磁盘的 I/O 情况，每个进程的 I/O 情况也是我们需要关注的重点。上面提到的 iostat 只提供磁盘整体的 I/O 性能数据，缺点在于，并不能知道具体是哪些进程在进行磁盘读写。要观察进程的 I/O 情况，你还可以使用 [pidstat](https://ghostwritten.blog.csdn.net/article/details/108978234) 和 [iotop](https://ghostwritten.blog.csdn.net/article/details/118698823) 这两个工具。pidstat 是我们的老朋友了，这里我就不再啰嗦它的功能了。给它加上 -d 参数，你就可以看到进程的 I/O 情况，如下所示：

```bash
$ pidstat -d 1 
13:39:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command 
13:39:52      102       916      0.00      4.00      0.00       0  rsyslogd
```
从 pidstat 的输出你能看到，它可以实时查看每个进程的 I/O 情况，包括下面这些内容。

 - 用户 ID（UID）和进程 ID（PID）  。
 - 每秒读取的数据大小（kB_rd/s） ，单位是 KB。
 - 每秒发出的写请求数据大小（kB_wr/s） ，单位是 KB。
 - 每秒取消的写请求数据大小（kB_ccwr/s） ，单位是 KB。
 - 块 I/O 延迟（iodelay），包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。


除了可以用 pidstat 实时查看，根据 I/O 大小对进程排序，也是性能分析中一个常用的方法。这一点，我推荐另一个工具， [iotop](https://ghostwritten.blog.csdn.net/article/details/118698823)。它是一个类似于 top 的工具，你可以按照 I/O 大小对进程排序，然后找到 I/O 较大的那些进程。


```bash
$ iotop
Total DISK READ :       0.00 B/s | Total DISK WRITE :       7.85 K/s 
Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s 
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND 
15055 be/3 root        0.00 B/s    7.85 K/s  0.00 %  0.00 % systemd-journald 
```
这个输出，你可以看到，前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等。剩下的部分，则是从各个角度来分别表示进程的 I/O 情况，包括线程 ID、I/O 优先级、每秒读磁盘的大小、每秒写磁盘的大小、换入和等待 I/O 的时钟百分比等。

## 8. 总结

我们梳理了 **Linux 磁盘 I/O** 的工作原理，并了解了由**文件系统层**、**通用块层**和**设备层**构成的 Linux 存储系统 I/O 栈。其中，**通用块层是 Linux 磁盘 I/O 的核心**。向上，它为文件系统和应用程序，提供访问了块设备的标准接口；向下，把各种异构的磁盘设备，抽象为统一的块设备，并会对文件系统和应用程序发来的 I/O 请求进行重新排序、请求合并等，提高了磁盘访问的效率。

我们梳理了 Linux 磁盘 I/O 的**性能指标**和**性能工具**。我们通常用 **IOPS、吞吐量、使用率、饱和度以及响应时间**等几个指标，来评估磁盘的 I/O 性能。你可以用 **iostat** 获得磁盘的 I/O 情况，也可以用 **pidstat、iotop** 等观察进程的 I/O 情况。不过在分析这些性能指标时，你要注意结合读写比例、I/O 类型以及 I/O 大小等，进行综合分析。




## 9. 讨论

```bash
1.用iostat看磁盘的await，utils，iops，bandwidth
2.用smartctl看磁盘的health status
3.用iotop/pidstat找出持续读写的进程做优化
```

