　Nginx是一个多进程程序,不同的worker进程之间,如果想要共享数据,那么只能通过共享内存;下面我们来看一看Nginx的共享内存是怎么使用的?
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2759ee08340488ff979f228f845cde5e.png)
**nginx的进程间的通讯方式主要有两种**

　　(1):第一种是**信号**,之前我们在说如何管理nginx的过程中已经比较详细的介绍过了;

　　(2):**共享内存**:如果需要做数据的同步 只能通过共享内存;所谓共享内存,也就是我们打开了一块内存,比如说10M,一整块0到10M之间,多个worker进程之间可以同时的访问它;包括读取和写入,那么为了使用好这样一个共享内存就会引入另外两个问题;**第一个问题就是锁**,因为多个worker进程同时操作一块内存,一定会存在竞争关系;所以我们需要加锁,在Nginx的锁中,**在早期,它还有基于信号量的锁**,**信号量是nginx比较久远的进程同步方式,它会导致你的进程进入休眠状态;也就是发送了主动切换**;而现在大多数操作系统版本中,**nginx所使用的锁都是自旋锁,而不会基于信号量;自旋锁也就是说当这个锁的条件没有满足比如说,这块内存现在被1号worker进程使用,2号worker进程需要去获取锁的时候,只要1号进程没有释放锁,2号进程会一直请求这把锁,就好像如果是基于信号量的早期的nginx锁,那么假设这把锁锁住了一扇门,如果worker进程1已经拿到了这把锁进到屋里,worker进程2是试图拿锁,敲门,发现里面已经有人了,那么worker进程2就会就地休息;等待worker进程1从门里出来以后通知它,而自旋锁不一样,那么worker进程2发现屋里已经有worker进程1了;它就会一直持续的去敲门,所以使用自旋锁要求所有的nginx模块,必须快速地使用共享内存,也就是快速的取得锁以后,快速的释放锁**,一旦发现有第三方模块不遵守这样的规则,就可能会导致出现**死锁或者说性能下降**的问题;那么有了这样的一块共享内存;会引入第二个问题;因为一整块共享内存是往往是给许多对象同时使用的;如果我们在模块中手动的去编写,分配把这些内存给到不同的对象,这是非常繁琐的;所以这个时候 我们使用了**Slab内存管理器**;

　　那么Nginx哪些模块使用了共享内存尼?
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/54b919eff580161adb076412eed48eec.png)
我对官方的常用的`Nginx`模块使用了共享内存做了一个总结:

　　使用共享内存主要使用了这两种数据结构:

　　(1):`rbtree`:红黑树 比如我们想做**限速**和**流控**等等场景时;我们是不能容忍在内存当中做的;否则一个worker进程对某一个用户触发了流控,而其它worker进程还不知道,所以我们只能在共享内存中做;红黑树有一个特点:**就是它的插入删除非常的快,当然也可以做遍历,所以如下的模块都有一个特点;需要做快速地插入和删除;**
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/224f622acb5706104c1cafcac32103f7.png)
比如我现在发现了一个客户端我对它限速,限速如果达到了,我需要把它从我的数据结构容器中移除,都需要非常的快速;
那么第二个常用的数据结构是单链表;也就是说我只需要把这些共享的元素串联起来就可以了;比如:

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/504f74dc2ff5de71d251984bf881dd6c.png)
我们来看个非常复杂的例子就是:`ngx_http_lua_api`

　　`ngx_http_lua_api` 这个模块**其实是openresty的核心模块**;openresty在这个模块中定义了一个`SDK`,这个SDK叫`lua_shared_dict`;当这个指令出现的时候,它会分配一块**共享内存**;比如说这里我们分了10m;这个共享内存会有一个名称叫做 `dogs`;
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f7bcb6426ec84fc4bd164fb30d24360a.png)
接下来我们在lua代码中,比如`content_by_lua_block`;对应着我们nginx收到了 set这个url的时候;需要做一些什么样的事情,我们首先从`dogs`共享内存中取出;然后设置了一个`key-value`; Jim-8;然后向客户端返回我已存储;

　　然后在get请求中我们把Jim的值8取出来;返回给用户;

　　那么在这一段代码中尼,我们同时使用了我们刚刚使用的**红黑树**和**单链表** 那么这个`lua_shared_dict` dogs 10m中使用红黑树来保存每一个key-value;红黑树中每一个节点就是Jim它的value就是8;那么为什么我还需要一个链表尼?是因为这个10m是有限的;当我们的Lua代码涉及到了我们的应用业务代码;很容易就超过了10m的限制;当我们出现10m限制的时候尼,会有很多种处理方法;比如让它写入失败;但是`lua_shared_dict` 采用了另外一种实现方式它用**lru淘汰**;也就是我最早set,最早get 长时间不用的那一个节点;比如前面还有Jim等于7或者等于6的节点;会优先被淘汰掉;当已经达到10m的最大值时;所以这个lua_shared_dict同时满足了**红黑树和链表**;

　　**共享内存是nginx跨worker进程通讯的最有效的手段;只要我们需要让一段业务逻辑在多个worker进程中同时生效;比如很多在做集群的流控上;那么必须使用共享内存;而不能在每一个worker内存中去操作;**
