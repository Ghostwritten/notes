之前我们提到**nginx的多个worker进程之间,做进程间通讯的时候,经常在共享内存上使用红黑树来管理许多对象,那么实际上在Nginx的内存上也会大量使用红黑树,现在我们来看看nginx中第二个非常常用的数据容器**,红黑树首先是个二叉树,比如每一个节点:比如下图11有两个子节点,左子节点是6,右子节点是15;那么红黑树的第二个特点尼它是一个查找二叉树,就是有顺序的,也就是我们左边的节点要比右边的节点要小,比如11的左子节点6,右子节点15,所有的节点都满足这一个特性;

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7574f3e1c479f9727c71766a76abfdae.png)
那么这样的一个二叉查找数,它有可能退化成一个链表,比如上图中右边的一张图,它们都没有左子节点,且都满足右边的节点大于左边的节点,大于根节点,那么这个时候在这样的链表二叉树上去查找某一个元素,它的遍历复杂度是O(n);而红黑树它有一个主要的特点,就是它的高度差不会很大, 比如左边3个高度:11-6-1,右边有11-15-22-25-27五个高度;不会超过最低的两倍,在nginx中描述每一个红黑树有一个数据结构叫做ngx_rbtree_t;root节点就是指向这个红黑树的根节点,红黑树会提供一些方法;红黑树里我们会很容易的找到最小的节点;比如最左边的子节点;我们用红黑树做定时器的时候;经常使用这个特性;那么红黑树还有哪些优点尼?

　　

 - (1):它的高度不会超过两倍的log(n);n就是节点数;
 - (2):对红黑树增删改查算法复杂度O(log(n));
 - (3):遍历复杂度是O(n)；为什么要单独提出来说尼?因为哈希表它的遍历的复杂度就不是O(n);而是它的bucket数量;

　　那么有了这些特点尼,我们就可以去判断**当使用了红黑树的模块,我们使用增删改查的时候,可以预测效率是很高的,而且如果它 提供了遍历这样的方法**;我们也完全可以使用;特别是针对Lua模块;因为Lua模块它的底层实现往往我们不太清楚;但是如果我们知道它是基于红黑树实现的;比如说我们刚刚所演示过的`share_direct`;那么我们就可以放心大胆的使用它的遍历和增删改查等等方法;

　　那么使用红黑树的模块有哪些尼?

　　实际上非常多,这只列举了官方一些常用的模块;

　　比如解析配置的`conf`模块;

　　`ngx_event_timer_rbtree` 虽然不是模块,但是是所有worker进程都会有的;管理定时器的红黑树;

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/64cd01bf07074bd27278ddbd29e325a8.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7aca3391fc3a03cc57b62250ebe99484.png)
　总结:我们了解到了红黑树的特性,可以放心的使用红黑树里面的很多方法;而不用纠结这样的一个方法我频繁的调用,会不会造成 性能问题;
